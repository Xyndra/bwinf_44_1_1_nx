use { sort_i64 } from std.collections
use { SetI64, set_i64_new, set_i64_add, set_i64_array } from std.collections.sets
use { define_map } from std.collections.generics

// Struct to hold intersection information
struct Intersection {
    i64 start = 0
    i64 end = 0
    [dyn]rune day = ""
    [dyn]Class classes = []
}

// Generate map from string to array of classes
$define_map("String", "[dyn]rune", "eqs", "Classes", "[dyn]Class", "[]")

// Find all intersections across all days
std find_intersections([dyn]Class classes): [dyn]Intersection {
    // Separate classes by day using map
    m classes_by_day = map_string_classes_new()

    m ci: i64 = 0
    c n = len(classes)
    subscope group_by_day {
        if (gei64(ci, n)) {
            exit group_by_day
        }
        c cls = classes[ci]
        c day = cls.day

        // Get existing classes for this day, append new one, and set back
        c existing = map_string_classes_get(classes_by_day, day)
        classes_by_day = map_string_classes_set(classes_by_day, day, push(existing, cls))

        ci = addi64(ci, 1)
        goto group_by_day
    }

    m intersections: [dyn]Intersection = []

    // Process each day
    c days = map_string_classes_keys(classes_by_day)
    m day_i: i64 = 0
    subscope process_days {
        if (gei64(day_i, len(days))) {
            exit process_days
        }
        c day = days[day_i]
        c day_classes = map_string_classes_get(classes_by_day, day)

        // Collect all time points for this day using a set
        m time_points_set = set_i64_new()
        m i: i64 = 0
        subscope collect_times {
            if (gei64(i, len(day_classes))) {
                exit collect_times
            }
            c cls = day_classes[i]
            time_points_set = set_i64_add(time_points_set, cls.start)
            time_points_set = set_i64_add(time_points_set, cls.end)
            i = addi64(i, 1)
            goto collect_times
        }

        // Get sorted time points array
        c time_points_arr = sort_i64(set_i64_array(time_points_set))

        // Build intersections for each time slot
        m ti: i64 = 0
        subscope build_intersections {
            if (gei64(addi64(ti, 1), len(time_points_arr))) {
                exit build_intersections
            }
            c start = time_points_arr[ti]
            c end = time_points_arr[addi64(ti, 1)]

            // Find overlapping classes
            m overlapping_classes: [dyn]Class = []
            m oci: i64 = 0
            subscope find_overlapping {
                if (gei64(oci, len(day_classes))) {
                    exit find_overlapping
                }
                c cls = day_classes[oci]
                if (and(lei64(cls.start, start), gei64(cls.end, end))) {
                    overlapping_classes = push(overlapping_classes, cls)
                }
                oci = addi64(oci, 1)
                goto find_overlapping
            }

            c intersection = Intersection {
                start: start,
                end: end,
                day: day,
                classes: overlapping_classes
            }
            intersections = push(intersections, intersection)

            ti = addi64(ti, 1)
            goto build_intersections
        }

        day_i = addi64(day_i, 1)
        goto process_days
    }

    return intersections
}
